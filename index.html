<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>dickmaggot.xyz</title>
<style>
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  @keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }
  html, body {
    margin: 0; padding: 0;
    height: 100%;
    background: #111;
    color: white;
    font-family: monospace, monospace;
    overflow: hidden;
  }
  #enterScreen {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    cursor: pointer;
    user-select: none;
    font-size: 3em;
    color: white;
    animation: fadeIn 3s ease forwards;
  }
  #terminal {
    display: none;
    padding: 20px;
    height: 100vh;
    box-sizing: border-box;
    overflow-y: auto;
    background: #111;
  }
  #output {
    white-space: pre-wrap;
    margin-bottom: 10px;
  }
  #inputLine {
    background: transparent;
    border: none;
    outline: none;
    color: white;
    font-family: monospace;
    font-size: 1.2em;
    width: 100%;
  }
  #visitCounter {
    position: fixed;
    bottom: 10px;
    right: 10px;
    font-family: monospace;
    color: white;
    display: none;
    align-items: center;
    gap: 6px;
    user-select: none;
  }
  #visitCounter svg {
    fill: white;
    width: 18px;
    height: 18px;
  }
  #gameOverOverlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: #111;
    color: red;
    font-size: 6em;
    font-weight: bold;
    justify-content: center;
    align-items: center;
    opacity: 0;
    pointer-events: none;
    z-index: 10000;
    user-select: none;
    font-family: monospace;
  }
</style>
</head>
<body>

<div id="enterScreen">Click to enter</div>

<div id="terminal" tabindex="0">
  <div id="output"></div>
  <input id="inputLine" autocomplete="off" autofocus />
</div>

<div id="visitCounter" title="Visit count">
  <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5c-7 0-11 7-11 7s4 7 11 7 11-7 11-7-4-7-11-7zm0 12a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM12 10a2 2 0 1 0 0 4 2 2 0 0 0 0-4z"/></svg>
  <span id="countNumber">0</span>
</div>

<div id="gameOverOverlay" style="display:flex;"></div>

<script>
  const enterScreen = document.getElementById('enterScreen');
  const terminal = document.getElementById('terminal');
  const output = document.getElementById('output');
  const inputLine = document.getElementById('inputLine');
  const visitCounter = document.getElementById('visitCounter');
  const countNumber = document.getElementById('countNumber');
  const gameOverOverlay = document.getElementById('gameOverOverlay');

  // Fade in "Click to enter" text
  enterScreen.style.opacity = 0;
  enterScreen.style.animation = 'fadeIn 3s ease forwards';

  // Terminal output helper
  function appendOutput(text) {
    output.textContent += text + "\n";
    output.scrollTop = output.scrollHeight;
  }

  // Placeholder visit count fetch - replace with your own API
  function fetchVisitCount() {
    // Just random number demo, replace with real API call
    let visits = Math.floor(Math.random() * 1000);
    countNumber.textContent = visits;
  }

  // Terminal commands & state
  let snakeCanvas = null;
  let ctx = null;
  let snake = [];
  let direction = {x: 0, y: 0};
  let food = null;
  let cols = 20;
  let rows = 20;
  let cellSize = 20;
  let gameInterval = null;

  function spawnFood() {
    let newFood;
    while(true) {
      newFood = {
        x: Math.floor(Math.random() * cols),
        y: Math.floor(Math.random() * rows)
      };
      // Make sure food not on snake
      if (!snake.some(s => s.x === newFood.x && s.y === newFood.y)) break;
    }
    return newFood;
  }

  function draw() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, snakeCanvas.width, snakeCanvas.height);

    // Draw food
    ctx.fillStyle = 'red';
    ctx.fillRect(food.x * cellSize, food.y * cellSize, cellSize, cellSize);

    // Draw snake
    ctx.fillStyle = 'white';
    snake.forEach(part => {
      ctx.fillRect(part.x * cellSize, part.y * cellSize, cellSize, cellSize);
    });
  }

  function update() {
    if(direction.x === 0 && direction.y === 0) return; // no movement yet

    // Calculate new head position
    let head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

    // Check wall collision
    if(head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows) {
      return gameOver();
    }

    // Check self collision
    if(snake.some(s => s.x === head.x && s.y === head.y)) {
      return gameOver();
    }

    snake.unshift(head);

    if(head.x === food.x && head.y === food.y) {
      food = spawnFood();
    } else {
      snake.pop();
    }

    draw();
  }

  function startGame() {
    // Setup canvas
    snakeCanvas = document.createElement('canvas');
    snakeCanvas.width = cols * cellSize;
    snakeCanvas.height = rows * cellSize;
    snakeCanvas.style.display = 'block';
    snakeCanvas.style.margin = '20px auto';
    snakeCanvas.style.background = '#111';
    terminal.innerHTML = '';
    terminal.appendChild(snakeCanvas);
    ctx = snakeCanvas.getContext('2d');

    // Init snake and direction
    snake = [{x: Math.floor(cols/2), y: Math.floor(rows/2)}];
    direction = {x: 0, y: 0};
    food = spawnFood();

    draw();
    if(gameInterval) clearInterval(gameInterval);
    gameInterval = setInterval(update, 100);
  }

  function gameOver() {
    clearInterval(gameInterval);

    // Show the overlay and fade it in
    gameOverOverlay.textContent = "GAME OVER";
    gameOverOverlay.style.display = 'flex';
    gameOverOverlay.style.pointerEvents = 'auto';
    gameOverOverlay.style.opacity = '0';

    let opacity = 0;
    let fadeInInterval = setInterval(() => {
      opacity += 0.05;
      if (opacity >= 1) {
        opacity = 1;
        clearInterval(fadeInInterval);

        // After 2 seconds fade out
        setTimeout(() => {
          let fadeOutInterval = setInterval(() => {
            opacity -= 0.05;
            if (opacity <= 0) {
              opacity = 0;
              clearInterval(fadeOutInterval);
              gameOverOverlay.style.display = 'none';
              gameOverOverlay.style.pointerEvents = 'none';

              // Cleanup and return to terminal
              if (snakeCanvas && snakeCanvas.parentNode) {
                terminal.removeChild(snakeCanvas);
                snakeCanvas = null;
              }
              terminal.style.display = 'block';
              inputLine.focus();

              // Reset game state variables for next start
              direction = { x: 0, y: 0 };
              snake = [{ x: Math.floor(cols/2), y: Math.floor(rows/2) }];
              food = spawnFood();
            }
            gameOverOverlay.style.opacity = opacity;
          }, 30);
        }, 2000);
      }
      gameOverOverlay.style.opacity = opacity;
    }, 30);
  }

  // Terminal commands
  function processCommand(cmd) {
    cmd = cmd.trim().toLowerCase();
    if(cmd === 'help') {
      appendOutput('Commands:\nhelp - Show commands\nsnake - Play snake\nclear - Clear terminal');
    } else if(cmd === 'clear') {
      output.textContent = '';
    } else if(cmd === 'snake') {
      appendOutput('Starting Snake! Use WASD or arrow keys to move. Avoid walls and yourself.');
      startGame();
    } else {
      appendOutput('Unknown command: ' + cmd);
    }
  }

  // Keyboard for terminal input
  inputLine.addEventListener('keydown', e => {
    if(e.key === 'Enter') {
      const cmd = inputLine.value;
      appendOutput('> ' + cmd);
      processCommand(cmd);
      inputLine.value = '';
    }
  });

  // Keyboard controls for snake
  window.addEventListener('keydown', e => {
    if (!snakeCanvas) return; // no snake game running
    switch(e.key) {
      case 'ArrowUp':
      case 'w':
      case 'W':
        if(direction.y !== 1) direction = {x: 0, y: -1};
        break;
      case 'ArrowDown':
      case 's':
      case 'S':
        if(direction.y !== -1) direction = {x: 0, y: 1};
        break;
      case 'ArrowLeft':
      case 'a':
      case 'A':
        if(direction.x !== 1) direction = {x: -1, y: 0};
        break;
      case 'ArrowRight':
      case 'd':
      case 'D':
        if(direction.x !== -1) direction = {x: 1, y: 0};
        break;
    }
  });

  // Enter screen click
  enterScreen.addEventListener('click', () => {
    enterScreen.style.animation = 'fadeOut 1s forwards';
    enterScreen.style.pointerEvents = 'none';
    setTimeout(() => {
      enterScreen.style.display = 'none';
      terminal.style.display = 'block';
      visitCounter.style.display = 'flex';

      // Request fullscreen
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen();
      } else if (document.documentElement.webkitRequestFullscreen) {
        document.documentElement.webkitRequestFullscreen();
      } else if (document.documentElement.msRequestFullscreen) {
        document.documentElement.msRequestFullscreen();
      }

      appendOutput('Welcome to the terminal. Type "help" for commands.');
      inputLine.focus();
      fetchVisitCount();
    }, 1000);
  });
</script>

</body>
</html>
